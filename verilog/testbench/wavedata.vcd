$date
	Sun Dec 31 16:45:28 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module testcache $end
$var wire 1 ! busywait $end
$var wire 32 " data [31:0] $end
$var parameter 32 # line_size $end
$var reg 32 $ address [31:0] $end
$var reg 1 % clk $end
$var reg 1 & reset $end
$var integer 32 ' i [31:0] $end
$scope module mycache $end
$var wire 32 ( address [31:0] $end
$var wire 1 ! busywait $end
$var wire 1 % clk $end
$var wire 1 & reset $end
$var wire 24 ) tag [23:0] $end
$var wire 2 * offset [1:0] $end
$var wire 4 + index [3:0] $end
$var parameter 32 , assiotivity $end
$var parameter 32 - index_depth $end
$var parameter 32 . line_size $end
$var parameter 32 / offset_size $end
$var parameter 35 0 tag_size $end
$var reg 32 1 data [31:0] $end
$var reg 1 2 hit $end
$var integer 32 3 i [31:0] $end
$var integer 32 4 j [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 5 \valid_bit_reg[18] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 6 \valid_bit_reg[19] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 7 \tag_reg[18] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 8 \tag_reg[19] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 9 \word_reg[74] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 : \word_reg[78] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 ; \word_reg[75] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 < \word_reg[79] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 = \valid_assiotivity[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 > \tag_assiotivity[0] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 ? \hit_tag_assiotivity[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 @ \hit_AND_valid[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 A \data_cache[0] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 B \valid_assiotivity[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 C \tag_assiotivity[1] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 D \hit_tag_assiotivity[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 E \hit_AND_valid[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 F \data_cache[1] [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b11000 0
b10 /
b100000 .
b100 -
b1 ,
b100000 #
$end
#0
$dumpvars
bx F
xE
xD
bx C
xB
bx A
x@
1?
bx >
x=
bx <
bx ;
bx :
b11 9
bx 8
b100000000000000000000001 7
x6
05
b10 4
b1 3
02
bx 1
bx +
bx *
bx )
bx (
b10 '
x&
1%
bx $
bx "
z!
$end
#1000
bx A
x@
1?
bx >
x=
06
05
b10 4
b1 3
1&
#2000
b11 9
b100000000000000000000001 7
05
b10 4
b10000 3
0&
#5000
0%
#7000
b11 A
0@
1?
b100000000000000000000001 >
0=
b1 3
b10 *
b1001 +
b100000000000000000000001 )
b10000000000000000000000110011010 $
b10000000000000000000000110011010 (
#10000
b11 9
b100000000000000000000001 7
05
b10 4
b10000 3
1%
#15000
0%
#17000
bx A
0@
0?
bx >
0=
b1 3
b0 *
b0 +
b0 )
b10 $
b10 (
#20000
b11 9
b100000000000000000000001 7
05
b10 4
b10000 3
1%
#25000
0%
#27000
06
05
b10 4
b10000 3
1&
#30000
06
05
b10 4
b10000 3
1%
#35000
0%
#37000
