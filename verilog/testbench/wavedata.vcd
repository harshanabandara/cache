$date
	Fri Jan 12 16:41:48 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module testcache $end
$var wire 32 ! data [31:0] $end
$var wire 1 " busywait $end
$var parameter 32 # line_size $end
$var reg 32 $ address [31:0] $end
$var reg 1 % clk $end
$var reg 1 & reset $end
$var integer 32 ' i [31:0] $end
$scope module mycache $end
$var wire 32 ( address_i [31:0] $end
$var wire 1 % clk_i $end
$var wire 1 & reset_i $end
$var wire 24 ) tag_addr [23:0] $end
$var wire 2 * offset_addr [1:0] $end
$var wire 4 + index_addr [3:0] $end
$var parameter 32 , c_assiotivity $end
$var parameter 32 - c_block_size $end
$var parameter 32 . c_index $end
$var parameter 32 / c_line_size $end
$var parameter 35 0 c_tag_size $end
$var reg 1 " c_busywait_o $end
$var reg 32 1 c_data_o [31:0] $end
$var reg 1 2 c_hit $end
$var integer 32 3 i [31:0] $end
$var integer 32 4 j [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 5 \c_valid_bit[18] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 6 \c_valid_bit[19] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 7 \c_tag[18] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 8 \c_tag[19] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 9 \c_word[74] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 : \c_word[78] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 ; \c_word[75] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 < \c_word[79] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 = \valid_bit_frm_c[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 > \tag_frm_c[0] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 ? \hit_frm_c[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 @ \hit_frm_c_AND_valid_bit_frm_c[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 A \data_frm_c[0] [31:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 B \valid_bit_frm_c[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 24 C \tag_frm_c[1] [23:0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 D \hit_frm_c[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 E \hit_frm_c_AND_valid_bit_frm_c[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 32 F \data_frm_c[1] [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b11000 0
b100000 /
b100 .
b10 -
b1 ,
b100000 #
$end
#0
$dumpvars
bx F
xE
xD
bx C
xB
bx A
x@
1?
bx >
x=
bx <
bx ;
bx :
b11 9
bx 8
b100000000000000000000001 7
x6
05
b10 4
b1 3
02
bx 1
bx +
bx *
bx )
bx (
b10 '
x&
1%
bx $
0"
bx !
$end
#1000
bx A
x@
1?
bx >
x=
06
05
b10 4
b1 3
1&
#2000
b11 9
b100000000000000000000001 7
05
b10 4
b10000 3
0&
#5000
0%
#7000
b11 A
0@
1?
b100000000000000000000001 >
0=
b1 3
b10 *
b1001 +
b100000000000000000000001 )
b10000000000000000000000110011010 $
b10000000000000000000000110011010 (
#10000
b11 9
b100000000000000000000001 7
05
b10 4
b10000 3
1"
1%
#15000
0%
#17000
bx A
0@
0?
bx >
0=
b1 3
b0 *
b0 +
b0 )
b10 $
b10 (
#20000
b11 9
b100000000000000000000001 7
05
b10 4
b10000 3
1%
#25000
0%
#27000
06
05
b10 4
b10000 3
1&
#30000
06
05
b10 4
b10000 3
1%
#35000
0%
#37000
