$date
	Sun Dec 31 11:38:55 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module testcache $end
$var wire 1 ! busywait $end
$var wire 32 " data [31:0] $end
$var parameter 32 # line_size $end
$var reg 32 $ address [31:0] $end
$var reg 1 % clk $end
$var reg 1 & reset $end
$var integer 32 ' i [31:0] $end
$scope module mycache $end
$var wire 32 ( address [31:0] $end
$var wire 1 ! busywait $end
$var wire 1 % clk $end
$var wire 1 & reset $end
$var wire 24 ) tag [23:0] $end
$var wire 2 * offset [1:0] $end
$var wire 4 + index [3:0] $end
$var parameter 32 , assiotivity $end
$var parameter 32 - index_depth $end
$var parameter 32 . line_size $end
$var parameter 32 / offset_size $end
$var parameter 35 0 tag_size $end
$var reg 32 1 data [31:0] $end
$var integer 32 2 i [31:0] $end
$var integer 32 3 j [31:0] $end
$scope begin cache_assiotivity[0] $end
$var wire 32 4 data_cache [31:0] $end
$var wire 1 5 hit_AND_valid $end
$var wire 24 6 tag_assiotivity [23:0] $end
$var wire 1 7 valid_assiotivity $end
$var wire 1 8 hit_assiotivity $end
$var parameter 2 9 assiotivity_num $end
$upscope $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 : \valid_bit_reg[0] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 ; \valid_bit_reg[1] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 < \valid_bit_reg[2] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 = \valid_bit_reg[3] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 > \valid_bit_reg[4] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 ? \valid_bit_reg[5] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 @ \valid_bit_reg[6] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 A \valid_bit_reg[7] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 B \valid_bit_reg[8] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 C \valid_bit_reg[9] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 D \valid_bit_reg[10] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 E \valid_bit_reg[11] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 F \valid_bit_reg[12] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 G \valid_bit_reg[13] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 H \valid_bit_reg[14] $end
$upscope $end
$upscope $end
$scope module testcache $end
$scope module mycache $end
$var reg 1 I \valid_bit_reg[15] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b0 9
b11000 0
b10 /
b100000 .
b100 -
b0 ,
b100000 #
$end
#0
$dumpvars
1I
1H
1G
1F
1E
1D
1C
1B
1A
1@
1?
1>
1=
1<
1;
1:
18
x7
bx 6
x5
bx 4
b1 3
b10000 2
bx 1
bx +
bx *
bx )
bx (
b10000 '
x&
1%
bx $
bx "
z!
$end
#1000
0I
0H
0G
0F
0E
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
b1 3
b10000 2
1&
#2000
1I
1H
1G
1F
1E
1D
1C
1B
1A
1@
1?
1>
1=
1<
1;
1:
b1 3
b10000 2
0&
#5000
0%
#7000
05
08
b11 *
17
b1001 +
b100000000000000000000001 )
b10000000000000000000000110011110 $
b10000000000000000000000110011110 (
#10000
1I
1H
1G
1F
1E
1D
1C
1B
1A
1@
1?
1>
1=
1<
1;
1:
b1 3
b10000 2
1%
#15000
0%
#17000
b0 *
b0 +
b0 )
b10 $
b10 (
#20000
1I
1H
1G
1F
1E
1D
1C
1B
1A
1@
1?
1>
1=
1<
1;
1:
b1 3
b10000 2
1%
#25000
0%
#27000
0I
0H
0G
0F
0E
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
07
b1 3
b10000 2
1&
#30000
0I
0H
0G
0F
0E
0D
0C
0B
0A
0@
0?
0>
0=
0<
0;
0:
b1 3
b10000 2
1%
#35000
0%
#37000
